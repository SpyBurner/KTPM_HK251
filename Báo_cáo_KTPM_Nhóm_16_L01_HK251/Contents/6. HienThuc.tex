\section{Hiện thực}
Đường dẫn xem các diagram: \url{https://drive.google.com/file/d/1uBsjoXb8VRKfoT2vgGVCYIc1MjsF7qjq/view?usp=sharing}

Đường dẫn repo Github: \url{https://github.com/SpyBurner/KTPM_HK251.git}
\subsection{API Gateway}

Ba lớp CustomJwtDecoder, JwtAuthenticationEntryPoint và SecurityConfig hợp tác với nhau để xây dựng pipeline xác thực JWT trong API Gateway. Mỗi lớp đảm nhiệm một vai trò riêng biệt nhưng phối hợp chặt chẽ để tạo thành cơ chế bảo mật thống nhất. 

\begin{enumerate}
	\item {Lớp CustomJwtDecoder}
	
	Lớp CustomJwtDecoder hiện thực interface ReactiveJwtDecoder, đóng vai trò là bộ giải mã JWT tùy chỉnh. Lớp này chứa ba thuộc tính chính: khóa ký (signerKey), thuật toán mã hóa (algorithm) và đối tượng giải mã Nimbus (nimbusJwtDecoder). Các thuộc tính này cung cấp thông tin cấu hình cần thiết để phân tích và xác thực token. 
	
	Phương thức trung tâm decode(String) thực hiện toàn bộ quá trình xác thực JWT. Khi nhận token đầu vào, phương thức này giải mã token, kiểm tra thời hạn hiệu lực và xác minh các claims bắt buộc. Kết quả trả về là đối tượng Jwt hợp lệ, được Spring Security sử dụng để tạo authentication context cho request. 
	
	Để hỗ trợ phương thức decode, lớp cung cấp các phương thức bổ trợ: getDecoder() khởi tạo đối tượng NimbusJwtDecoder với cấu hình đúng thuật toán và khóa ký; buildDecoder() tạo decoder thực tế dựa trên thuật toán được chọn; validateTokenExpiration(Jwt) kiểm tra token còn hiệu lực hay đã hết hạn; và validateTokenClaims(Jwt) xác minh token chứa đầy đủ thông tin định danh yêu cầu. 
	
	\item{Lớp JwtAuthenticationEntryPoint}
	
	Lớp JwtAuthenticationEntryPoint hiện thực interface ServerAuthenticationEntryPoint, đảm nhận vai trò xử lý lỗi xác thực. Lớp này sử dụng ObjectMapper cùng các thuộc tính cấu hình khác để tạo ra phản hồi lỗi chuẩn hóa. 
	
	Phương thức commence(ServerWebExchange, AuthenticationException) được Spring Security tự động gọi khi phát hiện request không hợp lệ hoặc thiếu token xác thực. Phương thức này xây dựng phản hồi JSON chứa mã lỗi, thông điệp mô tả và HTTP status code tương ứng. Cơ chế này đảm bảo mọi lỗi xác thực đều được trả về theo định dạng thống nhất, giúp client dễ dàng xử lý và hiển thị thông báo lỗi cho người dùng. 
	
	\item{Lớp SecurityConfig}
	
	Lớp SecurityConfig định nghĩa toàn bộ tác vụ bảo mật cho API Gateway. Lớp này khai báo các thuộc tính cấu hình quan trọng như danh sách endpoint công khai (PUBLIC\_ENDPOINTS), danh sách nguồn gốc được phép truy cập CORS (allowedOrigins), và hai dependency là ReactiveJwtDecoder và ServerAuthenticationEntryPoint. Lớp này có mối quan hệ dependency với hai interface này, cho phép Spring Container inject các implementation tương ứng thông qua constructor injection. 
	
	Phương thức springSecurityFilterChain(ServerHttpSecurity) là thành phần cốt lõi, thiết lập quy tắc phân quyền truy cập, tích hợp bộ giải mã JWT tùy chỉnh, và cấu hình authentication entry point xử lý lỗi. Phương thức corsConfigurationSource() tạo cấu hình CORS, cho phép API Gateway xử lý request từ các frontend domain được chỉ định một cách an toàn. Phương thức jwtAuthenticationConverter() định nghĩa cơ chế chuyển đổi authorities từ JWT claims thành các đối tượng GrantedAuthority mà Spring Security sử dụng để kiểm tra phân quyền. 
	
	\item{Mối quan hệ giữa các lớp}
	
	SecurityConfig có mối quan hệ aggregation với hai interface ReactiveJwtDecoder và ServerAuthenticationEntryPoint bởi vì nó sử dụng hai interface này như một phần của nó để thực hiện các tác vụ bảo mật của nó và vòng đời của hai interface này sẽ không phụ thuộc vào Security Config. CustomJwtDecoder hiện thực ReactiveJwtDecoder và sử dụng. JwtAuthenticationEntryPoint hiện thực. 
\end{enumerate}

\subsection{Class diagram cho Media Service}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{"Images/6. HienThuc/Class.png"}
	\caption{Class diagram cho Media Service}
	\label{fig:class1}
\end{figure}

Media Service được thiết kế theo mô hình nhiều lớp (layered architecture), trong đó các thành phần được phân chia rõ ràng theo trách nhiệm: lớp điều khiển (controller), lớp dịch vụ nghiệp vụ (service), lớp truy xuất dữ liệu (repository), và lớp tích hợp dịch vụ lưu trữ đám mây (cloud storage integration). Sơ đồ lớp (Class Diagram) được xây dựng nhằm mô tả mối quan hệ và vai trò của từng thành phần như sau: 
\begin{enumerate}
	\item{FileController: }
	
	FileController là lớp chịu trách nhiệm tiếp nhận mọi yêu cầu từ API Gateway. Mỗi endpoint được ánh xạ vào một phương thức tương ứng, sau đó chuyển tiếp tới tầng dịch vụ để xử lý nghiệp vụ. Lớp này có quan hệ aggregation với interface IFileService, cho phép sử dụng các chức năng nghiệp vụ mà không phụ thuộc vào lớp hiện thực cụ thể. FileController đảm nhiệm việc sinh Pre-Signed URL để frontend trực tiếp upload file lên dịch vụ lưu trữ, gửi yêu cầu lưu metadata sau khi file được tải lên, thực hiện xóa file media dựa trên ID hoặc key, truy xuất ảnh đại diện của người dùng thông qua username và lấy danh sách media thuộc về một Course Section. 
	
	\item{IFileService – Interface xử lý nghiệp vụ:}
	
	IFileService định nghĩa toàn bộ hành vi nghiệp vụ liên quan tới media file. Mục tiêu của interface là tạo ra lớp trừu tượng giúp Controller không phải phụ thuộc vào logic hiện thực. Các phương thức bao gồm: 
	
	\begin{itemize}
		\item Hoạt động sinh Pre-Signed URL thông qua hàm generatePresignedUrl(PreSignedUrlRequest) để frontend có thể upload trực tiếp lên S3; 
		\item Lưu metadata file upload với uploadMediaFile(MediaFileUploadRequest);  
		\item Xóa mediaFile thông qua deleteMediaFile(String fileIdOrKey);  
		\item Truy xuất ảnh đại diện của người dùng bằng getUserProfilePicture(String username); 
		\item Danh sách file thuộc một khóa học hoặc một section thông qua getCourseSectionMediaFile(Long sectionId). 
	\end{itemize}
	
	
	\item{FileService – Lớp hiện thực của IFileService:}  
	
	FileService hiện thực toàn bộ logic nghiệp vụ mô tả trong IFileService. Lớp này có quan hệ aggregation với FileRepository để làm việc với dữ liệu trong database và với ICloudStorageService để tương tác với dịch vụ lưu trữ đám mây. FileService thực hiện điều phối giữa hai tầng này, đảm bảo dữ liệu metadata và file lưu trữ trên file storage trên cloud được đồng bộ hóa. Ngoài ra, FileService còn chịu trách nhiệm thực hiện các kiểm tra nghiệp vụ như xác định folder lưu trữ dựa trên ngữ cảnh, thực hiện validate dữ liệu upload để đảm bảo đúng định dạng mong muốn, cũng như xử lý việc xóa file cũ khi một file mới được cập nhật. 
	
	\item{FileRepository – Tầng truy xuất dữ liệu:}
	
	FileRepository đóng vai trò là lớp giao tiếp với database theo chuẩn Spring Data. Interface này cung cấp các phương thức quan trọng phục vụ Media Service, chẳng hạn như deleteById(String id) để xóa metadata file dựa vào ID, và findByUsernameAndProfilePictureTrue(String username) để tìm file đóng vai trò là ảnh đại diện của một người dùng. Repository đảm bảo việc truy xuất và lưu trữ dữ liệu diễn ra nhất quán và tách biệt khỏi logic nghiệp vụ. 
	
	\item{ICloudStorageService – Lớp trừu tượng hóa dịch vụ lưu trữ đám mây:}  
	
	ICloudStorageService là lớp trừu tượng giúp Media Service có thể làm việc với nhiều provider như AWS S3, Google Cloud Storage hoặc Azure Blob mà không cần thay đổi logic nghiệp vụ. Interface này định nghĩa các phương thức cần thiết cho mọi hệ thống lưu trữ, chẳng hạn như sinh Pre-Signed URL thông qua generatePresignedUrl(...), xóa file bằng deleteFile(String key), xây dựng đường dẫn public URL với buildPublicUrl(String key), và xác định folder lưu trữ thích hợp dựa trên ngữ cảnh nghiệp vụ thông qua resolveFolder(String context). 
	
	\item{S3CloudStorageService – Hiện thực cho AWS S3:}  
	
	S3CloudStorageService là lớp hiện thực cụ thể của ICloudStorageService dành cho AWS S3. Toàn bộ logic làm việc với AWS SDK được đóng gói tại đây. Lớp này sử dụng S3Presigner để sinh Pre-Signed URL an toàn phục vụ upload; sử dụng S3Client để gọi các API thao tác trực tiếp với bucket; quản lý thông tin cấu hình như tên bucket và region. Bên cạnh việc sinh URL upload/download, lớp này còn hỗ trợ xóa file khỏi S3, xây dựng public URL dựa trên object key và xác định folder lưu trữ theo từng ngữ cảnh nghiệp vụ nhằm đảm bảo file được tổ chức theo cấu trúc nhất quán 
	
	\item{CloudStorageConfigInitializer:} 
	
	CloudStorageConfigInitializer là lớp chịu trách nhiệm khởi tạo toàn bộ cấu hình của các cloud storage provider ngay khi ứng dụng bắt đầu chạy. Các thuộc tính và phương thức bao gồm: 
	
	\begin{itemize}
		\item cloudStorageConfigs: Danh sách chứa tất cả các cấu hình của từng provider (S3, GCP Storage, Azure Blob…). Mỗi phần tử trong danh sách là một cấu hình độc lập, tuân theo interface CloudStorageConfig. 
		\item onApplicationEvent(ApplicationReadyEvent): Phương thức này được gọi khi ứng dụng khởi động xong. Lúc này CloudStorageConfigInitializer sẽ duyệt qua danh sách cloudStorageConfigs và gọi configure() trên từng config. Việc khởi tạo tập trung giúp đảm bảo mọi cloud provider đều sẵn sàng trước khi bất kỳ service nào trong hệ thống sử dụng chúng. 
	\end{itemize}
	
	
	\item{CloudStorageConfig: }
	
	CloudStorageConfig là một interface định nghĩa hợp đồng cho tất cả các loại cấu hình của các cloud storage provider. 
	
	Interface này đảm bảo rằng mọi provider đều tuân theo cùng một bộ hành vi, bao gồm: 
	\begin{itemize}
		\item configure(): Thiết lập và chuẩn bị toàn bộ tài nguyên cần thiết để provider hoạt động (client, credential, presigner…). 
		\item isEnabled(): Cho biết config có đang được bật bởi hệ thống hay không (đọc từ application.yml). 
		\item Điều này cho phép bật/tắt provider linh hoạt theo môi trường. 
		\item getProviderName(): Trả về tên của provider (ví dụ: "AWS\_S3" hoặc "GCP\_STORAGE"). 
		\item Hỗ trợ logging, debugging, hoặc chọn provider theo tên. 
	\end{itemize}
	
	
	Interface này giúp hệ thống dễ dàng mở rộng thêm provider mới bằng cách chỉ cần tạo class mới implement đúng hợp đồng này. 
	
	\item{S3Config: }
	
	S3Config là lớp triển khai cụ thể của CloudStorageConfig dành cho AWS S3. 
	Lớp này chịu trách nhiệm chuẩn bị toàn bộ thông tin cấu hình, client và credential để kết nối tới dịch vụ S3. Các thuộc tính liên quan đến cấu hình AWS S3, chẳng hạn như accessKey, secretKey, region, bucketName, presignerExpiration và các tham số khác cần thiết để hoạt động. 
	
	Phương thức:
	
	\begin{itemize}
		\item configure(): Hàm khởi tạo toàn bộ tài nguyên cần thiết cho AWS S3 như credential provider, S3Client và S3Presigner. Sau khi hàm này chạy, các service trong hệ thống có thể tương tác với S3 một cách ổn định. 
		\item isEnabled(): Kiểm tra xem S3 có được bật trong cấu hình hệ thống hay không (ví dụ cloud.aws.s3.enabled=true). Giúp linh hoạt bật/tắt từng provider. 
		\item getProviderName(): Trả về tên provider: "AWS\_S3". 
		\item credentialProvider(): Tạo provider chứa access key và secret key, phục vụ cho việc xác thực với AWS. Trả về StaticCredentialsProvider đảm bảo credential luôn sẵn sàng cho các client. 
		\item s3Presigner(): Tạo đối tượng presigner phục vụ việc tạo URL tải lên/tải xuống có thời hạn. 
		\item Đây là thành phần quan trọng trong việc xử lý pre-signed URL. 
		\item s3Client(): Tạo instance S3Client để thực thi các thao tác như upload, delete, copy hoặc kiểm tra object. Client này được cấu hình đúng region, credential và các tuỳ chọn liên quan. 
	\end{itemize}
\end{enumerate}

\textbf{Giải thích tuân theo nguyên tắc SOLID: }

\begin{enumerate}

	\item Single Responsibility Principle (SRP) – Nguyên tắc trách nhiệm đơn 
	
	Thiết kế của Media Service tuân thủ SRP bằng cách phân tách rõ ràng trách nhiệm của từng lớp trong hệ thống. Mỗi lớp chỉ đảm nhiệm một vai trò duy nhất và có một lý do để thay đổi. 
	
	\begin{itemize}
		\item 	FileController chỉ chịu trách nhiệm tiếp nhận và xử lý HTTP request từ API Gateway. Tất cả nghiệp vụ liên quan đến media đều được chuyển xuống tầng service, giúp Controller sạch, dễ bảo trì và không bị trộn lẫn logic. 
		\item 	FileService giữ vai trò duy nhất là xử lý logic nghiệp vụ của media. Mọi quyết định như xác định thư mục lưu trữ, validate thông tin upload, đồng bộ metadata hay xử lý xoá file đều được tập trung tại đây. 
		\item 	FileRepository đảm nhiệm việc tương tác với cơ sở dữ liệu — truy vấn, lưu, xoá metadata file. Repository không can thiệp vào nghiệp vụ hay xử lý đối với cloud storage. 
		\item 	ICloudStorageService và S3CloudStorageService tập trung hoàn toàn vào nhiệm vụ tương tác với hệ thống lưu trữ đám mây: sinh Pre-Signed URL, xoá file trên cloud, hoặc xây dựng public URL. 
		\item 	CloudStorageConfigInitializer: Chỉ chịu trách nhiệm khởi tạo tất cả cloud provider khi ứng dụng bắt đầu chạy. Nó không xử lý nghiệp vụ, không thao tác file. 
		\item 	CloudStorageConfig: Chỉ mô tả hợp đồng cấu hình cho từng provider. Interface này chỉ tập trung vào cấu hình – không tham gia xử lý logic hay lưu trữ. 
	\end{itemize}
	
	Nhờ sự phân tách này, khi logic liên quan đến request thay đổi, chỉ Controller bị tác động; khi nghiệp vụ thay đổi chỉ Service bị ảnh hưởng; và khi thay đổi provider lưu trữ cloud thì chỉ cần thay đổi lớp implementation tương ứng. Điều này giúp hệ thống dễ bảo trì, dễ mở rộng và giảm rủi ro phát sinh lỗi chéo giữa các tầng. 
	
	\item Open/Closed Principle (OCP) – Mở để mở rộng, đóng để sửa đổi 
	
	Media Service được thiết kế để hỗ trợ mở rộng tính năng mà không cần sửa đổi các thành phần đã ổn định. Điều này thể hiện rõ qua việc sử dụng interface để định nghĩa hành vi cốt lõi. 
	
	\begin{itemize}
		\item 	IFileService cho phép bổ sung các service mới mà không cần thay đổi FileController. Nếu sau này mở rộng hệ thống để hỗ trợ xử lý video, tạo thumbnail, nén file…, ta có thể cung cấp thêm implementation hoặc decorator mà không động đến logic hiện tại. 
		\item 	ICloudStorageService cho phép thay đổi hoặc mở rộng provider lưu trữ (AWS S3, GCP Storage, Azure Blob…) chỉ bằng cách tạo thêm lớp mới như GCPCloudStorageService hoặc AzureCloudStorageService. FileService sẽ hoạt động bình thường mà không cần chỉnh sửa, do phụ thuộc vào abstraction chứ không phải implementation cụ thể. 
		\item 	CloudStorageConfig (interface) cho phép bổ sung thêm config mới (GCPConfig, AzureConfig…) mà không chỉnh sửa logic khởi tạo. 
	\end{itemize}

	
	Nhờ thiết kế đóng để sửa đổi và mở để mở rộng, Media Service có khả năng phát triển lâu dài mà không ảnh hưởng đến sự ổn định của hệ thống. Mỗi lần mở rộng chỉ cần bổ sung module mới thay vì chỉnh sửa module đang hoạt động. 
	
	\item Liskov Substitution Principle (LSP) – Nguyên tắc thay thế Liskov 
	
	Hệ thống đảm bảo rằng mọi lớp con hoặc lớp hiện thực của một interface đều có thể thay thế cho class cha mà không làm thay đổi hành vi của toàn bộ Media Service. 
	
	\begin{itemize}
		\item S3CloudStorageService hoàn toàn có thể thay thế interface ICloudStorageService mà FileService đang sử dụng, và nếu triển khai thêm provider khác, implementation mới cũng phải đáp ứng đúng hợp đồng mà interface đưa ra. 
		\item 	
		\item Tương tự, FileService phải tuân thủ đầy đủ hành vi được mô tả trong IFileService để Controller có thể sử dụng mà không cần biết implementation phía sau. 
	\end{itemize}

	Nhờ đảm bảo đúng LSP, Media Service đạt được tính ổn định cao. Việc mở rộng hay thay đổi implementation không làm phá vỡ các tầng phía trên. Hệ thống luôn vận hành đúng dù sử dụng S3, GCP, Azure hay một storage provider mới. 
	
	\item Interface Segregation Principle (ISP) – Nguyên tắc phân tách interface 
	
	Media Service áp dụng ISP thông qua việc tách interface theo đúng domain của chúng, tránh tạo ra các interface cồng kềnh buộc class phải implement những phương thức không liên quan. 
	
	\begin{itemize}
		\item 	IFileService chỉ tập trung vào nghiệp vụ file (sinh Pre-Signed URL, lưu metadata, xoá file, lấy avatar, lấy media theo section). 
		\item 	ICloudStorageService chỉ mô tả chức năng liên quan đến thao tác cloud storage (tạo presigned URL, xây public URL, xoá file). 
		\item 	FileRepository chỉ mô tả các truy vấn cần thiết trên bảng file.
	\end{itemize}
	
	Việc phân tách interface theo đúng chức năng giúp hệ thống rõ ràng hơn, module nào chỉ dùng tính năng gì thì chỉ phụ thuộc vào interface đó. Từ đó giảm sự phụ thuộc không cần thiết, tăng khả năng tái sử dụng code và đơn giản hoá việc viết unit test. 
	
	\item Dependency Inversion Principle (DIP) – Nguyên tắc đảo ngược phụ thuộc 
	
	Các tầng cấp cao không phụ thuộc vào tầng cấp thấp, mà cả hai đều phụ thuộc vào abstraction. 
	
	\begin{itemize}
		\item FileController không phụ thuộc trực tiếp vào FileService, mà phụ thuộc vào interface IFileService. Điều này giúp Controller không bị ràng buộc vào một triển khai cụ thể. 
		\item FileService không phụ thuộc trực tiếp vào S3CloudStorageService, mà chỉ phụ thuộc vào abstraction ICloudStorageService. Nhờ đó, việc thay đổi provider cloud là hoàn toàn trong suốt đối với tầng service. 
		\item Repository cũng được sử dụng thông qua abstraction (do Spring Data tạo), giúp FileService hoàn toàn tách biệt khỏi công nghệ lưu trữ dữ liệu. 
		\item CloudStorageConfigInitializer Chỉ phụ thuộc vào danh sách CloudStorageConfig, không phụ thuộc vào S3Config cụ thể.
	\end{itemize}
\end{enumerate}

\subsection{Class diagram cho Module quản lý tài khoản}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{"Images/6. HienThuc/Class(1).png"}
	\caption{Class diagram cho Module quản lý tài khoản}
	\label{fig:class2}
\end{figure}

Identity Access Management (IAM) Service được thiết kế theo mô hình nhiều lớp (layered architecture), trong đó các thành phần được phân chia rõ ràng theo trách nhiệm: lớp điều khiển (controller), lớp dịch vụ nghiệp vụ (service), lớp giao diện xử lý token (token interface), và lớp truy xuất dữ liệu (repository). Sơ đồ lớp (Class Diagram) được xây dựng nhằm mô tả mối quan hệ và vai trò của từng thành phần trong việc xác thực và quản lý người dùng như sau: 
\begin{enumerate}
	\item AuthController: 
	
	AuthController là lớp chịu trách nhiệm tiếp nhận mọi yêu cầu liên quan đến xác thực và bảo mật từ API Gateway. Mỗi endpoint được ánh xạ vào một phương thức tương ứng như register, authenticate, introspect, refreshToken, và logout. Lớp này có quan hệ dependency với AuthenticationService, chuyển tiếp các yêu cầu tới tầng dịch vụ để xử lý logic. AuthController đóng vai trò là cổng giao tiếp chính, đảm bảo các yêu cầu HTTP được chuyển đổi thành dữ liệu nghiệp vụ để thực hiện đăng ký người dùng mới, xác minh danh tính, làm mới token khi hết hạn hoặc đăng xuất người dùng khỏi hệ thống. 
	
	\item AuthenticationService – Lớp dịch vụ xác thực trung tâm: 
	
	AuthenticationService là trái tim của hệ thống IAM, chịu trách nhiệm điều phối toàn bộ luồng nghiệp vụ xác thực. Lớp này tương tác với UserRepository để kiểm tra thông tin định danh, RoleRepository để gán quyền hạn, và AuthenticationService cũng tích hợp với các dịch vụ xử lý token để cấp phát quyền truy cập. Các phương thức chính bao gồm authenticate để xác thực thông tin đăng nhập, register để tạo tài khoản mới và logout để thực hiện vô hiệu hóa phiên làm việc hiện tại. 
	
	\item ITokenService và IJwtService – Các Interface xử lý Token: 
	
	Hai interface này định nghĩa toàn bộ hành vi liên quan đến việc quản lý vòng đời của token, tạo ra lớp trừu tượng giúp hệ thống không phụ thuộc chặt chẽ vào một thuật toán cụ thể. 
	
	IJwtService tập trung vào các thao tác cấp thấp với JWT như generateToken, extractClaim, isTokenValid(phương thức này đối với Interface này chỉ kiểm tra token dựa trên thời gian hết hạn), và extractUsername. 
	
	ITokenService mở rộng hoặc bao đóng các nghiệp vụ cao hơn như setTokenInvalid (đưa token vào danh sách đen) hay generateToken trả về đối tượng TokenPair (gồm Access và Refresh token), cũng như kiểm tra trạng thái của token đã bị thu hồi hay chưa thông qua phương thức isTokenInvalid. Khái niệm invalid ở interface này cho việc token bị thu hồi do hành động logout của người dùng trước khi token hết hạn. 
	
	\item TokenService và JwtService – Lớp hiện thực xử lý Token: 
	
	TokenService và JwtService hiện thực hóa các logic được định nghĩa trong interface. 
	
	JwtService chịu trách nhiệm về mặt kỹ thuật mật mã: ký token bằng secretKey, xác định thời gian hết hạn (expiration, refreshExpiration) và trích xuất thông tin từ chuỗi token. 
	
	TokenService sử dụng các khả năng này để quản lý trạng thái token, bao gồm việc tương tác với InvalidTokenRepository để kiểm tra xem một token có nằm trong danh sách bị thu hồi (revoked) hay không thông qua phương thức isTokenInvalid và thu hồi token thông qua phương thức setTokenInvalid. 
	
	\item UserController và UserService – Quản lý thông tin người dùng: 
	
	Cặp thành phần này quản lý các nghiệp vụ xoay quanh hồ sơ người dùng (User Profile). 
	
	UserController cung cấp các API để lấy thông tin (getUser, getAllUser), cập nhật hồ sơ (updateProfile) hoặc xóa người dùng. 
	
	UserService chứa logic nghiệp vụ để thực thi các yêu cầu này, thực hiện validate dữ liệu đầu vào và gọi xuống UserRepository để thao tác với cơ sở dữ liệu. Lớp này tách biệt hoàn toàn logic xử lý dữ liệu người dùng khỏi logic xác thực. 
	
	\item User, Role, Privilege – Các thực thể dữ liệu (Entities): 
	
	Đây là các lớp đại diện cho cấu trúc dữ liệu trong hệ thống. 
	
	User: Chứa thông tin định danh như username, email, passwordHash, và trạng thái hoạt động. 
	
	Role: Định nghĩa vai trò của người dùng trong hệ thống. 
	
	Privilege: Định nghĩa các quyền hạn cụ thể. 
	
	Quan hệ giữa chúng được thể hiện qua UserHasPrivilege và liên kết trực tiếp giữa User và Role, tạo nên mô hình phân quyền linh hoạt. 
	
	\item Tầng Repository (UserRepository, RoleRepository, InvalidTokenRepository): 
	
	Các interface này đóng vai trò là lớp giao tiếp với cơ sở dữ liệu (Data Access Layer). 
	
	UserRepository: Cung cấp các phương thức tìm kiếm người dùng theo username hoặc email (findByUsername, findByEmail) và kiểm tra sự tồn tại. 
	
	RoleRepository: Truy xuất thông tin vai trò dựa trên tên. 
	
	InvalidTokenRepository: Quản lý danh sách các token đã bị vô hiệu hóa (blacklist) để ngăn chặn việc tái sử dụng token sau khi đăng xuất (findById). 
	
	\item InvalidToken – Thực thể quản lý bảo mật: 
	
	InvalidToken là thực thể lưu trữ các token đã bị thu hồi cùng với thời gian thu hồi (revokeTime). Thành phần này cực kỳ quan trọng trong cơ chế bảo mật Statefull hoặc Hybrid, giúp hệ thống từ chối các request mang token hợp lệ về mặt chữ ký nhưng đã bị người dùng chủ động hủy bỏ (Logout). 
\end{enumerate}

\textbf{Giải thích tuân theo nguyên tắc SOLID: }

\begin{enumerate}
	\item Single Responsibility Principle (SRP) - Nguyên lý Đơn nhiệm 
	
	Đánh giá: Thiết kế này tuân thủ SRP rất chặt chẽ thông qua việc phân chia các tầng (Layered Architecture) và tách nhỏ các Service: 
	
	\begin{itemize}
		\item Tách biệt Controller và Service: 
	
		\begin{itemize}
			\item AuthController và UserController chỉ chịu trách nhiệm tiếp nhận request (HTTP), validate cơ bản và trả về response. 
			\item Logic nghiệp vụ phức tạp được đẩy xuống AuthenticationService và UserService. 
		\end{itemize}
	
		
		\item Tách biệt xử lý Token: Thay vì nhồi nhét logic xử lý chuỗi JWT vào AuthenticationService, thiết kế đã tách hẳn ra thành JwtService (lo các việc kỹ thuật như ký, giải mã, check hạn) và TokenService (lo các việc nghiệp vụ như tạo cặp token, blacklist token).  
	
		\item Tách biệt quản lý User: Các logic quản lý người dùng như việc xem thông tin và cập nhật thông tin người dùng được tách riêng biệt, không trộn lẫn với logic đăng nhập/đăng ký của AuthenticationService. 

	\end{itemize}

	\item Open/Closed Principle (OCP) - Nguyên lý Đóng/Mở 
	
	Đánh giá: Hệ thống có khả năng mở rộng mà không cần sửa đổi nhiều mã nguồn cũ nhờ vào việc sử dụng Interface: 
	
	\begin{itemize}
		\item 	Token Interface: Nếu hệ thống muốn thay đổi thuật toán ký JWT token (HS256 sang RS256) chỉ cần tạo một class mới implement ITokenService (hoặc implement cả IJwtService) mà không cần sửa đổi code trong AuthenticationService (nơi đang phụ thuộc vào các interface này). 
		\item 	Repository Pattern: Các UserRepository, RoleRepository là interface (chuẩn Spring Data JPA). Nếu muốn đổi database từ SQL sang MongoDB, chỉ cần đổi implement của Repository mà ít ảnh hưởng đến tầng Service. 
	\end{itemize}

	
	\item Liskov Substitution Principle (LSP) - Nguyên lý thay thế Liskov 
	
	Đánh giá: Trong sơ đồ này, quan hệ kế thừa chủ yếu nằm ở việc implements các Interface (TokenService implements ITokenService). 
	
	\begin{itemize}
		\item 	Mặc dù không thể nhìn thấy code chi tiết bên trong, nhưng về mặt thiết kế cấu trúc, TokenService cung cấp đầy đủ các phương thức mà ITokenService yêu cầu (generateToken, isTokenValid,...). 
		\item 	Miễn là TokenService không ném ra các ngoại lệ không mong muốn hoặc từ chối thực hiện hành vi đã định nghĩa trong Interface, nguyên lý này được đảm bảo. 
	\end{itemize}

	
	\item Interface Segregation Principle (ISP) - Nguyên lý phân tách Interface 
	
	Đánh giá: Thay vì tạo một Interface khổng lồ tên là ISecurityService chứa tất cả mọi thứ, thiết kế đã chia nhỏ: 
	
	\begin{itemize}
		\item 	IJwtService: Chỉ chứa các hàm kỹ thuật cấp thấp (extractClaim, buildToken, isTokenExpired). Dành cho các class cần thao tác trực tiếp với cấu trúc chuỗi token. 
		\item 	ITokenService: Chứa các hàm nghiệp vụ cao cấp hơn (setTokenInvalid, generateToken trả về TokenPair). 
		\item 	Lợi ích: AuthenticationService có thể chỉ cần inject ITokenService để lấy token trả về cho user mà không cần quan tâm đến các logic lấy quyền phức tạp của IJwtService. Client không bị phụ thuộc vào những hàm mà họ không dùng. 
	\end{itemize}

	
	\item Dependency Inversion Principle (DIP) - Nguyên lý đảo ngược sự phụ thuộc 
	
	Đánh giá: Thiết kế tuân thủ DIP thông qua việc các module cấp cao phụ thuộc vào abstraction (interface) thay vì module cấp thấp (concrete class). 
	
	Service phụ thuộc Interface: 
	
	\begin{itemize}
		\item 	AuthenticationService phụ thuộc vào ITokenService (Interface) chứ không phụ thuộc trực tiếp vào TokenService (Class cụ thể). Mũi tên dependency từ AuthenticationService trỏ vào ITokenService thể hiện điều này. 
		\item 	Các Service phụ thuộc vào UserRepository, RoleRepository (đều là Interface). 
	\end{itemize}
	
	Lưu ý: Giữa Controller và Service (AuthController -> AuthenticationService). Để đáp ứng tuyệt đối DIP, AuthenticationService và UserService cũng nên là Interface, và có các class AuthenticationServiceImpl, UserServiceImpl thực thi chúng. Tuy nhiên, trong thực tế với quy mô vừa phải, việc Controller gọi trực tiếp Service Class là chấp nhận được để giảm độ phức tạp không cần thiết (Pragmatic Architecture). 
\end{enumerate}

\subsection{Class diagram cho Module quản lý khóa học}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{"Images/6. HienThuc/Class(2).png"}
	\caption{Class diagram cho Module quản lý khóa học}
	\label{fig:class3}
\end{figure}

Course Service được thiết kế theo mô hình kiến trúc nhiều lớp (layered architecture), trong đó các thành phần được phân chia rõ ràng theo trách nhiệm: lớp điều khiển (controller), lớp dịch vụ nghiệp vụ (service), và lớp truy xuất dữ liệu (repository). Sơ đồ lớp (Class Diagram) được xây dựng nhằm mô tả mối quan hệ và vai trò của từng thành phần trong việc quản lý cấu trúc phân cấp của khóa học như sau: 
\begin{enumerate}
	\item  Hệ thống Controller – Tầng giao tiếp (Course, Chapter, Section, Topic, Enrollment) 
	
	Tầng Controller đóng vai trò là cửa ngõ tiếp nhận các yêu cầu HTTP từ Client. Thay vì dồn nén vào một Controller khổng lồ, hệ thống chia nhỏ thành các Controller chuyên biệt theo chức năng nghiệp vụ: 
	
	\begin{itemize}
		\item 	CourseController: Chỉ chịu trách nhiệm quản lý vòng đời cấp cao của thực thể Khóa học. Các endpoint ánh xạ vào các phương thức tạo mới, cập nhật, xóa và lấy thông tin chung của khóa học (getCourse, getCourses). Controller này đã được giải phóng khỏi nhiệm vụ truy xuất dữ liệu chi tiết bên trong (như danh sách chương). 
		\item 	ChapterController: Chuyên biệt quản lý thực thể Chương. Điểm cải tiến quan trọng trong thiết kế này là phương thức getChaptersByCourseId được đặt tại đây. Khi client cần danh sách chương của một khóa học, yêu cầu sẽ được gửi tới controller này, đảm bảo tính nhất quán trong quản lý tài nguyên chương. 
		\item 	SectionController: Quản lý đơn vị nhỏ nhất là Bài học. Tương tự, phương thức getSectionsByChapterId thuộc về controller này, chịu trách nhiệm truy xuất nội dung chi tiết (text, type) thuộc về một chương cụ thể.
	\end{itemize}
 
	Các Controller này hoạt động như một lớp điều phối (Delegator), không chứa logic nghiệp vụ phức tạp mà chuyển tiếp yêu cầu xuống tầng Service tương ứng. 
	
	\item  Tầng Service – Tầng xử lý nghiệp vụ 
	
	Các lớp Service này là trái tim của hệ thống quản lý nội dung, chịu trách nhiệm điều phối toàn bộ luồng nghiệp vụ cốt lõi, đảm bảo tính toàn vẹn của cấu trúc dữ liệu phân cấp: 
	
	\begin{itemize}
		\item 	CourseService: Đóng vai trò quản lý hồ sơ khóa học tổng quan. Nó tương tác với CourseRepository để thực hiện các tác vụ CRUD cơ bản. 
		\item 	ChapterService: Chứa logic nghiệp vụ liên quan đến cấu trúc chương. Phương thức getChaptersByCourseId tại đây sẽ gọi xuống Repository để lấy dữ liệu, đảm bảo rằng việc truy xuất danh sách chương được xử lý độc lập với logic của khóa học. 
		\item 	SectionService: Xử lý nghiệp vụ cho từng bài học chi tiết. Nó đảm bảo các bài học được tạo ra phải gắn liền với một chương hợp lệ (getSectionsByChapterId, createSection). 
	\end{itemize}

	\item Tầng Repository – Tầng truy xuất dữ liệu 
	
	Các interface này đóng vai trò là lớp giao tiếp với cơ sở dữ liệu (Data Access Layer). Thiết kế chia nhỏ Repository theo từng Entity giúp tối ưu hóa và chuyên biệt hóa truy vấn: 
	\begin{itemize}
		\item CourseRepository: Cung cấp các phương thức tìm kiếm cơ bản cho bảng Course. 
		\item ChapterRepository: Bổ sung phương thức truy vấn đặc thù findByCourseId, phục vụ trực tiếp cho nhu cầu lấy danh sách chương của ChapterService. 
		\item SectionRepository: Bổ sung phương thức findByChapterId, phục vụ cho nhu cầu lấy nội dung bài học của SectionService.
	\end{itemize}
 
	\item  Các thực thể dữ liệu (Entities) \& Mối quan hệ 
	
	Mô hình dữ liệu phản ánh cấu trúc cây (Tree Structure) chặt chẽ của một khóa học trực tuyến: 
	
	\begin{itemize}
		\item Course (Gốc): Chứa thông tin tổng quan (tên, mô tả, giảng viên, trạng thái). 
		\item Chapter (Nhánh): Liên kết trực tiếp với Course qua courseId. 
		\item Section (Lá): Đơn vị nội dung cuối cùng, liên kết với Chapter qua chapterId.
	\end{itemize}
 
\end{enumerate}

\textbf{Giải thích tuân theo nguyên tắc SOLID:}
\begin{enumerate}

	\item Nguyên lý Đơn nhiệm (Single Responsibility Principle – SRP) 
	
	Mỗi Controller chỉ quản lý một loại tài nguyên duy nhất: CourseController xử lý các request liên quan đến khóa học, ChapterController chuyên quản lý chương, còn SectionController chịu trách nhiệm cho section. Không có controller nào “ôm” logic của domain khác. Tương tự, các lớp Service như CourseService, ChapterService hay SectionService chỉ chứa logic nghiệp vụ đúng với miền dữ liệu của mình. Những thao tác truy cập dữ liệu lại được tách xuống các Repository riêng: CourseRepository, ChapterRepository, SectionRepository. 
	
	\item Nguyên lý Đóng/Mở (Open–Closed Principle – OCP) 
	
	ICourseService, IChapterService, ISectionService, IMediaService — cho phép hệ thống mở rộng mà không cần sửa code cũ. Các Controller chỉ biết đến interface, không biết đến class triển khai. Điều này tạo ra một ranh giới mở rộng rất an toàn để triển khai CourseServiceV2, thêm caching, refactor logic hoặc thay đổi thuật toán xử lý mà không cần chỉnh sửa CourseController. 
	
	Mỗi lớp Controller vốn đã “đóng” với thay đổi nhưng “mở” cho mở rộng thông qua việc bind một implementation khác vào interface. 
	
	\item Nguyên lý Thay thế Liskov (LSP) 
	
	Class diagram cho thấy các Service implementation đều tuân thủ hoàn toàn họ phương thức được định nghĩa trong interface. Điều này có nghĩa là bất kỳ implementation nào của ICourseService đều có thể thay thế cho một implementation khác trong Controller mà không làm thay đổi hành vi mong đợi. 
	
	Ví dụ như nếu chia CourseService thành hai class khác nhau — CourseServiceNormal và CourseServiceWithAI — thì Controller vẫn hoạt động bình thường chỉ bằng cách thay đổi injection.  
	
	\item Nguyên lý Phân tách Interface (ISP) 
	
	Các interface trong thiết kế được chia nhỏ đúng theo từng miền nghiệp vụ: ICourseService, IChapterService, ISectionService, IMediaService. Mỗi interface chỉ chứa các chức năng phục vụ trực tiếp domain tương ứng, không có phương thức thừa hoặc ép buộc class phải implement những thứ không cần. 
	
	Nhờ vậy, SectionService không bị buộc phải quan tâm đến logic của Course, và CourseService không phải chứa phương thức để uploadMedia hay xử lý chapter. Cách chia nhỏ interface này giúp code dễ hiểu hơn, dễ mock trong unit test, và đặc biệt phù hợp với mô hình microservice hoặc tách module về sau. 
	
	\item Nguyên lý Đảo ngược Phụ thuộc (Dependency Inversion Principle – DIP) 
	
	Tất cả các phụ thuộc trong class diagram đều trỏ từ lớp cấp cao sang abstraction thay vì implementation. Controller phụ thuộc vào interface của Service; Service lại phụ thuộc vào interface của Repository; còn Repository được Spring Data tạo implementation tự động. 

\end{enumerate}

\subsection{Class diagram cho Module học tập}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{"Images/6. HienThuc/Class(3).png"}
	\caption{Class diagram cho Module học tập}
	\label{fig:class4}
\end{figure}
\begin{enumerate}
	\item LearningController – Tầng giao tiếp xử lý hành vi học tập 
	
	LearningController giữ vai trò như điểm vào duy nhất cho toàn bộ hoạt động học tập của sinh viên. Khác với các Controller quản lý nội dung (như Course, Chapter hoặc Section), Controller này chỉ tập trung vào việc tiếp nhận và xử lý các hành vi động của người dùng trong quá trình học. Khi sinh viên đăng ký một khóa học mới, Controller tiếp nhận yêu cầu và chuyển cho học viên một EnrollmentDto phản ánh trạng thái ghi danh hiện tại. Trong các phiên học tiếp theo, Controller cũng chịu trách nhiệm trả về danh sách khóa học đã ghi danh và tiến trình học tập của từng khóa thông qua các phương thức tương ứng. Giao diện học tập cần hiển thị theo thời gian thực mức độ hoàn thành của từng chương, và LearningController đáp ứng điều này bằng cách gọi xuống tầng service để xây dựng CourseProgressResponse một cách nhất quán. 
	
	Ngoài ra, khi người học kết thúc một chương, Controller tiếp nhận tín hiệu hoàn thành và gửi yêu cầu xuống service để ghi nhận vào hệ thống tiến trình học tập. Nhờ đó, dữ liệu về tiến trình được cập nhật liên tục, phục vụ các tính năng khác như dashboard cá nhân hoặc gợi ý lộ trình học. Tất cả các nghiệp vụ này đều được triển khai theo nguyên tắc “thin controller”, tức là Controller chỉ làm nhiệm vụ điều phối và chuyển tiếp, nhằm giữ cho tầng giao tiếp luôn nhẹ và dễ duy trì. 
	
	\item LearningService – Tầng xử lý nghiệp vụ trọng tâm 
	
	LearningService đóng vai trò là tầng xử lý nghiệp vụ cốt lõi của toàn bộ module học tập, nơi tập hợp và điều phối mọi hoạt động liên quan đến hành trình học của sinh viên. Khi người dùng đăng ký một khóa học, service này kiểm tra trước trong EnrollmentRepository để đảm bảo rằng khóa học chưa được ghi danh trước đó. Việc ngăn chặn trùng lặp này đặc biệt quan trọng vì dữ liệu Enrollment là một trong những nền tảng quan trọng nhất của hệ thống, ảnh hưởng đến tiến trình học, hiển thị nội dung và các thuật toán gợi ý. 
	
	Trong quá trình học tập, LearningService cũng chịu trách nhiệm quản lý toàn bộ thông tin về tiến độ học tập. Khi giao diện yêu cầu tiến trình của một khóa học, service sẽ tổng hợp dữ liệu từ nhiều nguồn: số chương trong khóa, số chương đã hoàn thành, cùng với trạng thái chi tiết của từng chương. Nhờ đó, service này hoạt động như một bộ “orchestrator”, kết hợp và chuẩn hóa dữ liệu để tạo ra một phản hồi chính xác và dễ sử dụng cho UI. 
	
	Một nghiệp vụ khác rất quan trọng là việc đánh dấu chương học đã hoàn thành. LearningService không chỉ xác minh xem bản ghi về việc hoàn thành chương đã tồn tại hay chưa mà còn chịu trách nhiệm tạo bản ghi mới một cách an toàn. Điều này đảm bảo rằng tiến trình học tập được ghi nhận chính xác và không bị trùng lặp, đồng thời hỗ trợ tốt cho các tính năng nâng cao như đánh giá năng lực, phân tích hành vi học hoặc gợi ý nội dung học phù hợp. 
	
	Tổng thể, LearningService đóng vai trò như trung tâm điều phối, đảm bảo mọi logic nghiệp vụ được xử lý đúng domain, không phụ thuộc vào tầng lưu trữ dữ liệu và không bị chi phối bởi tầng hiển thị. 
	
	\item Repository Layer – Tầng truy cập dữ liệu cho Enrollment và Progress 
	
	Tầng Repository trong module Learning được thiết kế tách biệt hoàn toàn theo từng thực thể, đảm bảo tính chuyên biệt và tối ưu hóa truy vấn. EnrollmentRepository chịu trách nhiệm xử lý trực tiếp dữ liệu liên quan đến việc ghi danh khóa học, trong đó phương thức tìm kiếm theo studentId cho phép hệ thống nhanh chóng trả về danh sách khóa học mà sinh viên đang học. Bên cạnh đó, phương thức kiểm tra sự tồn tại của bản ghi theo studentId và courseId là công cụ chính để LearningService bảo vệ dữ liệu khỏi trùng lặp, đảm bảo tính nhất quán suốt vòng đời của Enrollment. 
	
	Song song với đó, ProgressRepository được thiết kế để phục vụ việc truy xuất và lưu trữ tiến trình chương học. Đây là tầng chuyên dụng cho thực thể StudentFinishChapter, giúp xác minh xem chương đã được hoàn thành trước đó hay chưa. Khi có bản ghi mới, ProgressRepository đảm nhận nhiệm vụ lưu trữ và cập nhật. Nhờ kiến trúc phân tách rõ ràng này, mỗi repository chỉ phục vụ đúng một nhu cầu nghiệp vụ duy nhất, phù hợp với nguyên tắc SRP và đảm bảo hệ thống dễ bảo trì trong tương lai. 
	
	\item Entity Model – Cấu trúc dữ liệu phản ánh hành trình học tập 
	
	Phần mô hình dữ liệu của module Learning được xây dựng dựa trên thực tế hoạt động học tập của sinh viên trong hệ thống. Thực thể Enrollment đóng vai trò là “chứng nhận” việc sinh viên đã đăng ký một khóa học cụ thể. Ngoài các thông tin căn bản như studentId, courseId và thời điểm đăng ký, nó còn chứa thêm các trường như isStarred hoặc isSaved, phục vụ cho các chức năng nâng cao của hệ thống như ghim khóa học, cá nhân hóa dashboard hoặc lưu khóa học để học sau. 
	
	Thực thể StudentFinishChapter biểu diễn chi tiết từng chương mà sinh viên đã hoàn thành. Mỗi bản ghi trong bảng này tương ứng với một mốc quan trọng trong tiến trình học, cho phép hệ thống theo dõi sự tiến bộ theo thời gian. Thông tin này không chỉ phục vụ cho việc tính toán tiến độ học mà còn có thể dùng để phân tích hành vi học tập hoặc hỗ trợ các thuật toán recommendation. 
	
	Nhờ mối quan hệ chặt chẽ giữa Enrollment và StudentFinishChapter, module Learning mô phỏng chính xác vòng đời của hành trình học tập của người dùng trong môi trường e-learning, đảm bảo tính toàn vẹn, minh bạch và khả năng mở rộng trong tương lai. 
\end{enumerate}

\textbf{Giải thích tuân theo nguyên tắc SOLID:}

\begin{enumerate}
	\item Nguyên lý Đơn nhiệm (Single Responsibility Principle – SRP) 
	
	Thiết kế trong sơ đồ Learning thể hiện rõ cách phân tách trách nhiệm theo từng cấp và từng loại dữ liệu. LearningController chỉ chịu trách nhiệm tiếp nhận và chuyển tiếp yêu cầu từ client, chẳng hạn lấy danh sách khóa học mà sinh viên đã đăng ký, đánh dấu hoàn thành chapter, hoặc xem tiến trình học. Tất cả logic nghiệp vụ phức tạp như kiểm tra sinh viên đã enroll hay chưa, tính toán tiến trình khóa học, xác định chapter đã hoàn thành… đều được đóng gói trong LearningService, giúp controller không bị “phình to” với logic. 
	Ở tầng dữ liệu, các repository phụ trách các nhiệm vụ rất cụ thể: EnrollmentRepository chỉ xử lý dữ liệu enrollment (đăng ký khóa học), còn ProgressRepository chịu trách nhiệm lưu và truy vấn thông tin hoàn thành từng chapter. Tách nhiệm vụ theo đối tượng dữ liệu như vậy đảm bảo rằng mỗi lớp chỉ thay đổi khi nghiệp vụ liên quan đến đối tượng đó thay đổi. Điều này giúp mô-đun Learning dễ bảo trì, dễ mở rộng và dễ viết unit test từng phần độc lập. 
	
	\item Nguyên lý Đóng/Mở (Open–Closed Principle – OCP) 
	
	Sự hiện diện của interface ILearningService đóng vai trò như một lớp trừu tượng để Controller giao tiếp. Nhờ đó, LearningController hoàn toàn không phụ thuộc vào implementation cụ thể của LearningService. Nếu trong tương lai muốn mở rộng nghiệp vụ (ví dụ: thêm tracking chi tiết từng phút học, hoặc áp dụng công nghệ event sourcing để ghi log tiến trình học), thì chỉ cần tạo một LearningService mới mà không phải chỉnh sửa bất kỳ dòng code nào của controller. 
	
	\item Nguyên lý Thay thế Liskov (LSP) 
	
	Interface ILearningService đóng vai trò như một hợp đồng rõ ràng cho các lớp triển khai. Controller chỉ cần biết đến interface này, đảm bảo rằng bất kỳ implementation nào cũng có thể thay thế cho implementation hiện tại mà không thay đổi hành vi hệ thống. 
	Giả sử muốn bổ sung một phiên bản LearningService sử dụng AI để gợi ý lộ trình học thông minh thì chỉ cần viết LearningServiceV2 và đảm bảo tuân thủ interface. Vì mọi hành vi đều được mô tả trong hợp đồng, Controller có thể hoạt động với cả hai implementation mà không cần thay đổi. Điều này thể hiện đúng tinh thần LSP: thay thế implementation mà không phá vỡ logic luồng xử lý đã có. 
	
	\item Nguyên lý Phân tách Interface (Interface Segregation Principle – ISP) 
	
	Thiết kế chia interface phân tách theo đúng domain: ILearningService, EnrollmentRepository, ProgressRepository. Mỗi interface chỉ phục vụ đúng nhiệm vụ liên quan: LearningService giải quyết nghiệp vụ huấn luyện; EnrollmentRepository cung cấp khả năng truy vấn enrollment; ProgressRepository xử lý trạng thái hoàn thành chapter. 
	
	Không có class nào phải implement hoặc phụ thuộc vào các phương thức thừa, không liên quan. Ví dụ, EnrollmentRepository không hề chứa phương thức để lưu tiến trình học, và ProgressRepository cũng không chứa logic liên quan đến việc kiểm tra khóa học đã được enroll chưa. Sự phân tách gọn gàng này giúp hệ thống dễ mở rộng, giảm độ coupling và tránh việc một service phải biết “quá nhiều”. 
	
	\item Nguyên lý Đảo ngược Phụ thuộc (Dependency Inversion Principle – DIP) 
	
	Controller trong sơ đồ luôn phụ thuộc vào abstraction là ILearningService, chứ không phụ thuộc trực tiếp vào LearningService. Điều này tạo nên một thiết kế ổn định, không bị phụ thuộc cứng vào bất kỳ implementation cụ thể nào. LearningService lại phụ thuộc vào abstraction của repository (EnrollmentRepository và ProgressRepository), giúp toàn bộ tầng nghiệp vụ tách biệt khỏi tầng dữ liệu. 
\end{enumerate}

\subsection{Class diagram cho Module quiz}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{"Images/6. HienThuc/Class(4).png"}
	\caption{Class diagram cho Module quiz}
	\label{fig:class5}
\end{figure}
\begin{enumerate}
	
	\item QuizController – Tầng giao tiếp xử lý hoạt động quiz 
	
	QuizController đóng vai trò là cổng giao tiếp cho tất cả thao tác liên quan đến quiz trong hệ thống. Khi giảng viên tạo, cập nhật hoặc xóa quiz, Controller tiếp nhận yêu cầu và chuyển xuống tầng service để xử lý nghiệp vụ. Với các thao tác truy vấn như lấy danh sách quiz theo khóa học hoặc theo người tạo, Controller chỉ giữ nhiệm vụ điều phối dữ liệu, đảm bảo luồng vào/ra đơn giản, rõ ràng. Việc tách riêng QuestionController giúp hệ thống xử lý chuyên biệt các thao tác CRUD của câu hỏi mà không làm QuizController trở nên cồng kềnh. Cách tổ chức này duy trì nguyên tắc “thin controller”, nơi controller không chứa bất kỳ logic nghiệp vụ phức tạp nào, giúp mã nguồn dễ đọc và dễ bảo trì. 
	
	\item QuizAttemptController – Tầng giao tiếp xử lý hoạt động làm bài 
	
	QuizAttemptController phụ trách toàn bộ vòng đời thực hiện quiz của sinh viên. Khi sinh viên bắt đầu làm bài, controller tạo một phiên làm bài mới thông qua service và trả về thông tin phiên đó. Khi sinh viên hoàn thành và nộp bài, controller chuyển toàn bộ thông tin câu trả lời xuống service để thực hiện chấm điểm tự động. Controller cũng cung cấp các API để xem lịch sử làm bài theo sinh viên hoặc theo quiz. Nhờ đảm nhận vai trò điều phối nhẹ nhàng và giao toàn bộ logic chấm điểm cho service, controller đảm bảo giao diện API REST tuân thủ chuẩn và dễ dàng tích hợp với frontend. 
	
	\item IQuizService – Tầng nghiệp vụ xử lý quiz 
	
	IQuizService định nghĩa toàn bộ nghiệp vụ cốt lõi của quiz như tạo mới, cập nhật, xóa và truy vấn quiz. Implementation của service chịu trách nhiệm xử lý các logic phức tạp như kiểm tra tính hợp lệ của quiz, quản lý các câu hỏi và đáp án đi kèm, cũng như đảm bảo dữ liệu nhất quán khi cập nhật hoặc xóa quiz. Nhờ abstraction từ interface, controller không cần biết implementation cụ thể và hệ thống dễ dàng mở rộng — ví dụ khi cần thêm dạng quiz mới hoặc cần bổ sung cơ chế cấu hình bài kiểm tra nâng cao. 
	
	\item IQuestionService – Tầng nghiệp vụ xử lý câu hỏi 
	
	IQuestionService quản lý độc lập vòng đời của từng câu hỏi mà không phụ thuộc vào toàn bộ quiz. Service xử lý việc thêm mới, chỉnh sửa hoặc xóa câu hỏi, đồng thời đảm bảo rằng mỗi câu hỏi luôn có đáp án phù hợp và dữ liệu luôn ổn định. Khi cập nhật câu hỏi, service đồng bộ lại các đáp án liên quan và đảm bảo không phá vỡ dữ liệu được tham chiếu bởi các phiên làm bài đã tồn tại. Nhờ tách riêng service này ra khỏi IQuizService, hệ thống dễ dàng mở rộng và thao tác trên câu hỏi trở nên an toàn, linh hoạt hơn. 
	
	\item IQuizAttemptService – Tầng nghiệp vụ làm bài và chấm điểm 
	
	IQuizAttemptService đóng vai trò trọng tâm trong hoạt động làm bài. Service xử lý việc khởi tạo phiên làm bài, lưu trữ câu trả lời, tính toán điểm số và xác định kết quả đạt hay không đạt. Khi nộp bài, service so sánh các đáp án sinh viên chọn với đáp án đúng được lưu trong hệ thống để tính điểm chính xác. Service cũng xử lý các trường hợp đặc biệt như hết thời gian hoặc nhiều lần làm bài tùy theo cấu hình của quiz. Toàn bộ logic chấm điểm và xác thực đều nằm ở tầng này, giúp controller và repository không bị lẫn lộn nghiệp vụ. 
	
	\item Repository Layer – Tầng truy cập dữ liệu 
	
	Tầng repository được phân tách theo từng domain: QuizRepository xử lý dữ liệu quiz, QuestionRepository xử lý câu hỏi, AnswerRepository xử lý đáp án, QuizAttemptRepository quản lý phiên làm bài, và QuizAttemptAnswerRepository lưu chi tiết câu trả lời. Mỗi repository chỉ chịu trách nhiệm với đúng một entity duy nhất, cung cấp các phương thức truy xuất dữ liệu theo nhu cầu của từng service. Cách tách này giúp dữ liệu được quản lý rõ ràng, truy vấn tối ưu và bám sát nguyên tắc SRP. 
	
	\item Entity Model – Cấu trúc dữ liệu của hệ thống đánh giá 
	
	Các entity Quiz, Question, Answer, QuizAttempt và QuizAttemptAnswer xây dựng nên mô hình dữ liệu mô phỏng hoạt động kiểm tra trực tuyến. Quiz lưu cấu hình tổng thể của bài kiểm tra; Question lưu nội dung câu hỏi; Answer lưu các lựa chọn và đánh dấu đáp án đúng; QuizAttempt lưu thông tin mỗi lần làm bài của sinh viên; và QuizAttemptAnswer lưu chi tiết từng đáp án mà sinh viên đã chọn. Cấu trúc quan hệ chặt chẽ này giúp hệ thống truy vết chính xác từng hành vi làm bài và hỗ trợ chấm điểm tự động hiệu quả. 
\end{enumerate}

\textbf{Giải thích tuân theo nguyên tắc SOLID:}

\begin{enumerate}

	\item Nguyên lý Đơn nhiệm (Single Responsibility Principle – SRP) 
	
	QuizController chỉ chịu trách nhiệm tiếp nhận và chuyển tiếp yêu cầu từ client, chẳng hạn tạo quiz mới, cập nhật quiz, hoặc lấy danh sách quiz theo người tạo. QuestionController tách biệt để xử lý riêng các thao tác với câu hỏi, và QuizAttemptController chuyên xử lý việc sinh viên làm bài. 
	
	Ở tầng dữ liệu, các repository phụ trách các nhiệm vụ rất cụ thể: QuizRepository chỉ xử lý dữ liệu quiz, QuestionRepository quản lý câu hỏi, AnswerRepository quản lý đáp án, QuizAttemptRepository xử lý phiên làm bài, và QuizAttemptAnswerRepository lưu trữ chi tiết câu trả lời.  
	
	\item Nguyên lý Đóng/Mở (Open–Closed Principle – OCP) 
	
	Sự hiện diện của các interface IQuizService, IQuestionService và IQuizAttemptService đóng vai trò như các lớp trừu tượng để Controller giao tiếp. Nhờ đó, các Controller hoàn toàn không phụ thuộc vào implementation cụ thể của Service. Nếu trong tương lai muốn mở rộng nghiệp vụ (ví dụ: thêm chức năng quiz thích ứng - adaptive quiz dựa trên AI, hoặc áp dụng thuật toán chấm điểm phức tạp hơn với trọng số từng câu hỏi, hoặc tích hợp với hệ thống anti-cheating), thì chỉ cần tạo implementation mới như QuizServiceV2 hoặc AIBasedQuizAttemptService mà không phải chỉnh sửa bất kỳ dòng code nào của controller. 
	
	\item Nguyên lý Thay thế Liskov (Liskov Substitution Principle – LSP) 
	
	Các interface IQuizService, IQuestionService và IQuizAttemptService đóng vai trò như các hợp đồng rõ ràng cho các lớp triển khai. Controller chỉ cần biết đến các interface này, đảm bảo rằng bất kỳ implementation nào cũng có thể thay thế cho implementation hiện tại mà không thay đổi hành vi hệ thống. 
	
	Giả sử muốn bổ sung một phiên bản QuizAttemptService sử dụng machine learning để phát hiện gian lận dựa trên pattern làm bài (thời gian giữa các câu trả lời, độ tương đồng với bài làm của người khác), thì chỉ cần viết AnticheatQuizAttemptService và đảm bảo tuân thủ interface. Tương tự, nếu cần tạo một AdvancedQuizService hỗ trợ question pool (ngân hàng câu hỏi ngẫu nhiên) hoặc question branching (câu hỏi tiếp theo phụ thuộc vào câu trả lời trước đó), miễn là nó triển khai đúng IQuizService, toàn bộ hệ thống vẫn hoạt động ổn định. 
	
	\item Nguyên lý Phân tách Interface (Interface Segregation Principle – ISP) 
	
	Thiết kế chia interface phân tách theo đúng domain: IQuizService quản lý quiz, IQuestionService quản lý câu hỏi, IQuizAttemptService quản lý việc làm bài. Mỗi interface chỉ phục vụ đúng nhiệm vụ liên quan và không bắt buộc class triển khai phải implement các phương thức không cần thiết. 
	
	Ví dụ, IQuizAttemptService không chứa các phương thức createQuiz() hay updateQuestion() - những phương thức này không liên quan đến nghiệp vụ làm bài. Ngược lại, IQuizService không chứa phương thức calculateScore() vì việc chấm điểm là trách nhiệm của attempt service. Sự phân tách gọn gàng này giúp hệ thống dễ mở rộng, giảm độ coupling và tránh việc một service phải biết "quá nhiều" về các domain khác. 
	
	\item Nguyên lý Đảo ngược Phụ thuộc (Dependency Inversion Principle – DIP) 
	
	Controller trong sơ đồ luôn phụ thuộc vào abstraction (IQuizService, IQuestionService, IQuizAttemptService), chứ không phụ thuộc trực tiếp vào các implementation cụ thể (QuizServiceImpl, QuestionServiceImpl, QuizAttemptServiceImpl).  
	
	Service layer lại phụ thuộc vào abstraction của repository (QuizRepository, QuestionRepository, AnswerRepository, QuizAttemptRepository, QuizAttemptAnswerRepository), giúp toàn bộ tầng nghiệp vụ tách biệt khỏi tầng dữ liệu. 
	
	Việc áp dụng DIP này đặc biệt quan trọng trong môi trường microservices hoặc khi cần viết integration test. Các abstraction cho phép dễ dàng mock hoặc stub các dependency, giúp test từng layer độc lập mà không cần khởi động toàn bộ hệ thống.  

\end{enumerate}

\subsection{Class diagram cho Module AI}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{"Images/6. HienThuc/Class(5).png"}
	\caption{Class diagram cho Module AI}
	\label{fig:class5}
\end{figure}
\begin{enumerate}
	
	\item  AgentController – Tầng giao tiếp xử lý yêu cầu AI 
	
	AgentController đóng vai trò là cổng giao tiếp duy nhất (Entry Point) cho các yêu cầu phân tích và tư vấn từ phía người dùng (Client). Khi người dùng yêu cầu phân tích lộ trình học hoặc đề xuất khóa học, Controller tiếp nhận request (thường chứa userId), xác thực cơ bản, và chuyển tiếp yêu cầu đó xuống tầng Agent để xử lý.  Lớp này tuân thủ nguyên tắc "thin controller", không chứa logic suy luận AI hay logic gọi API bên thứ 3, đảm bảo đầu mối giao tiếp RESTful API luôn gọn nhẹ và dễ bảo trì. 
	
	\item  OrchestratorAgent – Tầng điều phối thông minh (Supervisor) 
	
	OrchestratorAgent đóng vai trò là "nhạc trưởng" hay bộ não trung tâm của AI Service. Thay vì trực tiếp thực hiện mọi tác vụ, nó chịu trách nhiệm phân tích ý định của người dùng và điều phối công việc cho các Agent chuyên biệt (Worker) hoặc quyết định luồng xử lý chính. Ví dụ, khi nhận yêu cầu phức tạp, Orchestrator sẽ xác định xem cần gọi LearningAnalysisAgent để phân tích dữ liệu hay gọi một Agent khác để tư vấn tâm lý. Việc tách tầng điều phối này giúp hệ thống dễ dàng mở rộng sang mô hình Multi-Agent trong tương lai mà không làm rối luồng xử lý chính. 
	
	\item  LearningAnalysisAgent – Tầng nghiệp vụ phân tích chuyên sâu (Worker) 
	
	LearningAnalysisAgent là thành phần cốt lõi thực hiện các nghiệp vụ cụ thể như phân tích hành vi học tập và gợi ý lộ trình. Agent này được cấu hình với các System Prompt chuyên biệt để đóng vai trò như một chuyên gia giáo dục. Điểm đặc biệt là Agent này không hoạt động độc lập; nó được trang bị các "Tools" (công cụ) để có thể tương tác với thế giới bên ngoài. Khi cần dữ liệu để suy luận, Agent sẽ tự động quyết định việc gọi các Function (Tools) để lấy lịch sử học tập hoặc điểm thi, sau đó tổng hợp thông tin để đưa ra câu trả lời cuối cùng dưới dạng JSON hoặc văn bản tự nhiên. 
	
	\item  AnalysisPromptManager – Tầng quản lý ngữ cảnh và chỉ thị (Prompt Engineering) 
	
	AnalysisPromptManager chịu trách nhiệm quản lý toàn bộ các câu lệnh chỉ dẫn (System Prompt) và mẫu câu hỏi (User Prompt) cho AI. Việc tách biệt quản lý Prompt ra khỏi logic code Java giúp lập trình viên dễ dàng tinh chỉnh "tính cách" và "luật chơi" của AI mà không cần biên dịch lại mã nguồn. Interface IAnalysisPromptManager đảm bảo rằng các Agent khác nhau có thể sử dụng các chiến lược Prompt khác nhau nhưng vẫn tuân thủ cùng một chuẩn giao tiếp. 
	
	\item  Tools \& Functions Layer – Tầng công cụ mở rộng (Function Calling) 
	
	Đây là các lớp chức năng (FetchLearningHistoryFunction, FetchQuizResultsFunction, FetchCourseCatalogFunction) đóng vai trò là "cánh tay nối dài" của AI. Mỗi Function được đăng ký như một java.util.function.Function trong Spring AI Context. Chúng đóng gói logic nghiệp vụ để chuyển đổi yêu cầu từ ngôn ngữ tự nhiên của AI thành các lệnh gọi hàm Java cụ thể. Tầng này giúp AI có khả năng hành động thực tế (lấy dữ liệu, tra cứu) thay vì chỉ là một chatbot trả lời văn bản tĩnh. 
	
	\item  Infrastructure \& Gateway Layer – Tầng kết nối  (Anti-Corruption Layer) 
	
	Tầng này bao gồm các Interface Gateway (ILearningService, IQuizService, ICourseService) và các Implementation (Remote...Adapter). Nhiệm vụ của chúng là thực hiện các giao tiếp mạng (thông qua RestClient hoặc WebClient) sang các  khác như Learning Service, Quiz Service hay Course Service. Việc sử dụng Adapter Pattern ở đây giúp cách ly AI Service khỏi sự thay đổi của các service bên ngoài. Nếu API của Quiz Service thay đổi, ta chỉ cần sửa RemoteQuizServiceAdapter, logic của AI Agent hoàn toàn không bị ảnh hưởng. 

\end{enumerate}

\textbf{Giải thích tuân theo nguyên tắc SOLID:}
\begin{enumerate}
	\item Nguyên lý Đơn nhiệm (Single Responsibility Principle – SRP) 
	
	\begin{itemize}
		\item 	AgentController: Chỉ lo việc nhận/trả HTTP request. 
		\item 	OrchestratorAgent: Chỉ lo điều phối luồng hội thoại. 
		\item 	LearningAnalysisAgent: Chỉ tập trung vào nghiệp vụ phân tích giáo dục. 
		\item 	Fetch...Function: Chỉ làm nhiệm vụ chuyển đổi dữ liệu để AI hiểu. 
		\item 	Remote...Adapter: Chỉ lo việc gọi API sang service khác. Sự phân chia này giúp code rõ ràng, mỗi class chỉ thay đổi vì một lý do duy nhất. 
	\end{itemize}

	
	\item Nguyên lý Đóng/Mở (Open–Closed Principle – OCP) 
	Hệ thống được thiết kế để mở rộng khả năng của AI mà không cần sửa đổi code lõi. 
	\begin{itemize}
		\item 	Nếu muốn AI có thêm khả năng mới (ví dụ: xem thời khóa biểu), ta chỉ cần tạo thêm FetchScheduleFunction và đăng ký nó vào Agent. Không cần sửa logic suy luận bên trong LearningAnalysisAgent. 
		\item 	Nếu muốn thay đổi model từ OpenAI sang Gemini, chỉ cần thay đổi cấu hình trong ChatModel, code logic trong Agent giữ nguyên. 
		\item 	Việc có một lớp Orchestrator giữa lớp xử lý yêu cầu người dùng và lớp chính của nó. Điều này cho phép mở rộng ra hệ thống multi-agent khi chỉ cần hiện thực thêm agent và đăng ký nó đến Orchestrator 
	\end{itemize}
	
	\item Nguyên lý Thay thế Liskov (Liskov Substitution Principle – LSP) 
	
	Các Gateway Interface (ILearningService, IQuizService) đóng vai trò hợp đồng. 
	
	\begin{itemize}
		\item 	RemoteLearningServiceAdapter có thể được thay thế bằng MockLearningServiceAdapter (dữ liệu giả lập) trong môi trường kiểm thử (Unit Test) mà không làm hỏng logic của FetchLearningHistoryFunction. Hệ thống hoạt động đúng đắn bất kể implementation nào được inject vào. 
	\end{itemize}

	
	\item Nguyên lý Phân tách Interface (Interface Segregation Principle – ISP) 
	
	Thay vì tạo một IGlobalServiceGateway khổng lồ chứa tất cả các hàm gọi API, hệ thống chia nhỏ thành ILearningService, IQuizService, ICourseService. 
	
	\begin{itemize}
		\item 	FetchQuizResultsFunction chỉ cần biết đến IQuizService, nó không cần phụ thuộc vào các phương thức liên quan đến Course hay Learning. Điều này giảm sự phụ thuộc chéo không cần thiết giữa các module. 
	\end{itemize}

	
	\item Nguyên lý Đảo ngược Phụ thuộc (Dependency Inversion Principle – DIP) 
	
	\begin{itemize}
		\item 	Agent (High-level Module) không phụ thuộc trực tiếp vào RemoteServiceAdapter (Low-level Module). 
		\item 	Cả hai đều phụ thuộc vào Abstraction (Interface). 
		\begin{itemize}
			\item 	LearningAnalysisAgent phụ thuộc vào Function (Tool). 
			\item 	FetchLearningHistoryFunction phụ thuộc vào ILearningService. 
			\item 	Việc khởi tạo cụ thể (Dependency Injection) do Spring Container đảm nhận. Điều này giúp kiến trúc lỏng lẻo (loose coupling), dễ dàng bảo trì và kiểm thử độc lập. 
		\end{itemize}
	\end{itemize}

\end{enumerate}

\subsection{Class diagram cho Module Logging}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{"Images/6. HienThuc/Class(6).png"}
	\caption{Class diagram cho Module Logging}
	\label{fig:class6}
\end{figure}

\begin{enumerate}
	\item LoggingController – Tầng giao tiếp tiếp nhận yêu cầu ghi Log 
	
	LoggingController đóng vai trò là cổng giao tiếp duy nhất (Entry Point) cho các yêu cầu liên quan đến nhật ký hệ thống (System Logs) và nhật ký hoạt động AI (AI Logs). Khi các service khác hoặc client gửi yêu cầu ghi log hoặc truy xuất lịch sử, Controller tiếp nhận request, thực hiện các validate cơ bản và điều hướng đến service tương ứng (SystemLogService hoặc AILogService). Lớp này tuân thủ nguyên tắc "thin controller", chỉ làm nhiệm vụ điều phối luồng dữ liệu thông qua các Interface, đảm bảo tính tách biệt giữa giao diện API và logic xử lý nghiệp vụ bên dưới. 
	
	\item Service Layer (ISystemLogService \& IAILogService) – Tầng trừu tượng hóa nghiệp vụ 
	
	Đây là các Interface định nghĩa "hợp đồng" (Contract) cho các nghiệp vụ xử lý log. Việc tách biệt thành hai interface riêng biệt (ISystemLogService và IAILogService) giúp hệ thống phân định rõ ràng trách nhiệm: một bên chuyên xử lý các log vận hành hệ thống (lỗi, cảnh báo), một bên chuyên xử lý log tương tác với AI (prompt, token usage). Điều này giúp Controller không cần biết chi tiết cách log được lưu hay xử lý như thế nào, mà chỉ cần biết các phương thức được cung cấp. 
	
	\item Implementation Layer (SystemLogServiceImpl \& AILogServiceImpl) – Tầng thực thi nghiệp vụ (Worker) 
	
	Đây là nơi chứa logic nghiệp vụ cốt lõi: 
	
	\begin{itemize}
		\item 	SystemLogServiceImpl: Chịu trách nhiệm xử lý các log hệ thống. Điểm đặc biệt là nó có sự tương tác với AlertService. Khi một log có mức độ nghiêm trọng (Severity) cao được ghi nhận, Service này có thể tự động kích hoạt gửi cảnh báo. Nó cũng gọi xuống Repository để lưu trữ dữ liệu. 
		\item 	AILogServiceImpl: Chuyên xử lý việc lưu trữ và truy xuất các tương tác AI (câu hỏi, câu trả lời, số token). Logic ở đây tập trung vào việc đảm bảo dữ liệu tương tác AI được ghi nhận chính xác để phục vụ việc audit hoặc tính phí (token usage). 
	\end{itemize}

	
	\item AlertService – Tầng tích hợp thông báo (Integration) 
	
	AlertService đóng vai trò là một service bổ trợ, được sử dụng bởi SystemLogServiceImpl. Chức năng duy nhất của nó là sendAlert(message), giúp gửi cảnh báo ra bên ngoài (có thể là Email, Slack, hoặc SMS) khi hệ thống gặp sự cố nghiêm trọng. Việc tách Alert thành một service riêng giúp logic ghi log không bị trộn lẫn với logic gửi thông báo. 
	
	\item Repository Layer – Tầng truy xuất dữ liệu (Data Access) 
	
	SystemLogRepository và AILogRepository đóng vai trò là lớp trừu tượng để tương tác với cơ sở dữ liệu. Các Interface này cung cấp các phương thức chuẩn như save(entity) và findByFilters(filters). Tầng này đảm bảo rằng các Service ở tầng trên không phụ thuộc vào công nghệ lưu trữ cụ thể (SQL hay NoSQL), giúp việc thay đổi database sau này trở nên dễ dàng mà không ảnh hưởng đến logic nghiệp vụ. 
	
	\item Entity Layer (BaseLog, SystemLog, AILog) – Tầng mô hình dữ liệu (Data Model) 
	
	Hệ thống sử dụng mô hình thừa kế để quản lý dữ liệu log một cách hiệu quả: 
	
	BaseLog (Abstract): Chứa các trường thông tin chung nhất mà mọi loại log đều có (id, createdAt, trackedUserId), giúp tránh lặp lại code (DRY - Don't Repeat Yourself). 
	
	SystemLog: Mở rộng từ BaseLog, bổ sung các trường đặc thù cho vận hành như message và severity (Mức độ nghiêm trọng). 
	
	AILog: Mở rộng từ BaseLog, bổ sung các trường đặc thù cho AI như prompt (câu lệnh), response (phản hồi), và tokenUsage. 
\end{enumerate}

\textbf{Giải thích tuân theo nguyên tắc SOLID:}
\begin{enumerate}
	\item Nguyên lý Đơn nhiệm (Single Responsibility Principle – SRP) 
	
	\begin{itemize}
		\item 	LoggingController: Chỉ chịu trách nhiệm nhận và trả kết quả HTTP, không chứa logic xử lý log. 
		\item 	AlertService: Chỉ có duy nhất một nhiệm vụ là gửi cảnh báo, không quan tâm log được lưu như thế nào. 
		\item 	SystemLogServiceImpl: Tập trung vào logic nghiệp vụ của log hệ thống. 
		\item 	AILog: Chỉ chứa dữ liệu liên quan đến AI, không chứa dữ liệu về mức độ nghiêm trọng của hệ thống. 
		\item 	Mỗi class trong sơ đồ đều có một trách nhiệm duy nhất và rõ ràng, giúp code dễ đọc và dễ bảo trì. 
	\end{itemize}
	
	\item Nguyên lý Đóng/Mở (Open–Closed Principle – OCP) 
	
	Hệ thống được thiết kế để dễ dàng mở rộng: 
	
	\begin{itemize}
		\item 	Mở rộng loại Log: Nếu cần thêm loại log mới (ví dụ: AuditLog cho giao dịch tài chính), ta chỉ cần tạo class AuditLog kế thừa từ BaseLog và tạo thêm Service/Repository tương ứng mà không cần sửa đổi class BaseLog hay các Service hiện có. 
		\item 	Mở rộng logic Alert: Nếu muốn thay đổi cách gửi thông báo (từ Email sang Slack), ta chỉ cần sửa hoặc mở rộng implementation của AlertService mà không ảnh hưởng đến SystemLogServiceImpl. 
	\end{itemize}

	
	\item Nguyên lý Thay thế Liskov (Liskov Substitution Principle – LSP) 
	
	\begin{itemize}
		\item 	Entity: SystemLog và AILog đều kế thừa từ BaseLog. Ở bất kỳ đâu trong hệ thống cần xử lý thông tin cơ bản (như lấy createdAt), ta có thể truyền vào instance của SystemLog hoặc AILog mà chương trình vẫn hoạt động đúng đắn. 
		\item 	Service: SystemLogServiceImpl thực thi ISystemLogService. Trong controller, ta tham chiếu đến Interface. Nếu ta tạo một MockSystemLogService để chạy Unit Test, controller vẫn hoạt động bình thường mà không cần biết đó là đồ giả hay đồ thật. 
	\end{itemize}

	
	\item Nguyên lý Phân tách Interface (Interface Segregation Principle – ISP) 
	
	Thay vì tạo một IGeneralLogService khổng lồ chứa cả hàm logSystemActivity và logAIActivity, hệ thống đã tách thành hai interface nhỏ: 
	
	\begin{itemize}
		\item 	ISystemLogService: Chỉ chứa các hàm liên quan log hệ thống. 
		\item 	IAILogService: Chỉ chứa các hàm liên quan log AI. 
		\item 	Điều này đảm bảo rằng nếu một client chỉ quan tâm đến AI Logs, họ không bị buộc phải phụ thuộc vào các phương thức của System Logs mà họ không dùng đến. 
	\end{itemize}

	\item Nguyên lý Đảo ngược Phụ thuộc (Dependency Inversion Principle – DIP) 
	
	\begin{itemize}
		\item 	High-level Module (LoggingController): Không phụ thuộc trực tiếp vào Low-level Module (SystemLogServiceImpl, AILogServiceImpl). Thay vào đó, nó phụ thuộc vào Abstraction (ISystemLogService, IAILogService). 
		\item 	Service Layer: Các Service implementation không phụ thuộc trực tiếp vào Database connection cụ thể, mà phụ thuộc vào Repository Interface (SystemLogRepository, AILogRepository). 
		\item 	Nhờ DIP, việc thay đổi implementation bên dưới (ví dụ đổi logic lưu log từ MySQL sang MongoDB) sẽ không làm ảnh hưởng đến code của Controller hay Service. 
	\end{itemize}

\end{enumerate}